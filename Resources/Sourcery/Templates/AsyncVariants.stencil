{% for type in types.all %}
{% for method in type.methods where method.annotations.AsyncVariants %}
{% set methodName %}{% for value in method.name|split:"(" %}{% if forloop.first %}{{ value }}{% endif %}{% endfor %}{% endset %}
// sourcery:file:StytchCore/Generated/{{ type.name }}.{{ methodName }}+AsyncVariants.generated.swift
import Combine
import Foundation

public extension {{ type.name }} {
{% set methodKeywords %}{% if method.isClass %}class {% elif method.isStatic %}static {% endif %}func{% endset %}
{% set methodDeclaration %}{{ methodName }}({% for parameter in method.parameters %}{% if not forloop.last %}{% if not forloop.first %}, {% endif %}{{ parameter.asSource }}{% endif %}{% endfor %}){% endset %}
{% set methodCallParams %}{% for parameter in method.parameters %}{% if not forloop.last %}{{ parameter.name }}: {{ parameter.name }}, {% endif %}{% endfor %}completion: {% endset %}
{% set returnType %}{{ method.parameters.last.typeName|replace:"@escaping Completion<",""|replace:">","" }}{% endset %}
{% set asyncFunction %}
    {{ methodKeywords }} {{ methodDeclaration }} async throws -> {{ returnType }} {
        try await withCheckedThrowingContinuation { continuation in
            {{ methodName }}({{ methodCallParams }}continuation.resume)
        }
    }
{% endset %}
{% set methodDocs %}
{% for commentLine in method.documentation %}
    /// {{ commentLine|replace:"  - completion:","- Returns:" }}
{% endfor %}
{% endset %}
    {{ methodDocs }}
    {{ methodKeywords }} {{ methodDeclaration }} -> AnyPublisher<{{ returnType }}, Error> {
        return Deferred { 
            Future({ promise in
                {{ methodName }}({{ methodCallParams }}promise)
            })
        }
        .eraseToAnyPublisher()
    }

    {{ methodDocs }}
    {{ asyncFunction }}
}
// sourcery:end
{% endfor %}
{% endfor %}
